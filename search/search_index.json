{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Voor organisaties","text":""},{"location":"#onder-ontwikkeling","title":"Onder ontwikkeling","text":"<p>We werken momenteel aan de ontwikkeling van deze sectie om een uitgebreide bron van informatie te bieden. Het doel is om organisaties te ondersteunen met gidsen, best practices en antwoorden op veelgestelde vragen die essentieel zijn voor het gebruik van het Netherlands3D platform.</p> <p>In de tussentijd moedigen we u aan om contact met ons op te nemen bij vragen met betrekking tot het platform. </p> <p>Blijf op de hoogte voor updates en verbeteringen aan deze sectie. We kijken ernaar uit om te voorzien in de informatie en hulpmiddelen die nodig zijn om goed gebruik te maken van Netherlands3D.</p>"},{"location":"BAG/","title":"BAG informatie na klikken op gebouw","text":"<p>Warning</p> <p>Dit deel van de documentatie is nog gebaseerd op een oudere versie van het project. We werken aan een nieuwe versie  die deze spoedig zal vervangen.</p> <p>Het Netherlands3D pakketje bevat een voorbeeld om BAG informatie op te halen van een pand door er op te klikken. Importeer het BAG-information voorbeeld via de Package Manager*.</p> <p></p> <p>Je kunt de Package Manager boven in Unity vinden onder 'Window/Package Manager'</p> <p>Open vervolgens de geimporteerde voorbeeld Scene genaamd \u2018ShowBAGInformationOnClick\u2019</p> <p>Je kan de scene even uitproberen door op de Play knop te drukken.  Klik nu op een van de panden die worden ingeladen door te TileHandler, en je zult zien dat het pand wordt uitgelicht met een kleur en de daarbij behorende BAG informatie wordt getoond in een voorbeeld interface.</p> <p></p> <p>Toevoegen aan eigen Scene/TileHandlerOm dit te laten werken in je eigen scene moeten we een aantal dingen kopieren. Om te beginnen hebben we het Select Sub Objects script nodig die op het Buildings object staat in de TileHandler van de voorbeeld Scene. Kopieer die dmv. rechtermuisklik, \u2018Copy Component\u2019, en vervolgens \u2018Paste Component As New\u2019 op je eigen Buildings object in je scene.  Op deze manier kopieer je ook de instellingen van het voorbeeld direct mee.</p> <p>Verander eventueel de Selection Vertex Color om een andere selectiekleur te gebruiken</p> <p>Kopieer dan de volgende objecten vanuit de voorbeeld Scene naar je eigen Scene:</p> <p>InputEvents - Dit systeem zorgt er voor dat je muis klik acties worden verstuurd</p> <p>BAGBuildingDataLoader - Dit systeem download de Pand BAG informatie</p> <p>BAGResidenceDataLoader - Dit systeem download de adressen van een pand</p> <p>Canvas - Dit Canvas bevat de voorbeeld interface met de twee panelen</p> <p>EventSystem - Deze zorgt er voor dat het Canvas aanklikbaar is. Misschien heb je deze al in je eigen Scene. Dan kan je deze overslaan.</p> <p>We moeten er ook nog voor zorgen dat het materiaal dat in je Scene wordt toegewezen aan de gebouwen ondersteuning heeft om de gebouwkleur te wijzigen. Stel daarom bij je Binary Mesh Layer van je gebouwen object bij Default Material List het Buildings_SelectionVertexColoring materiaal in.</p> <p></p> <p>Je kan een materiaal vanuit je Assets op het element slepen, of via het bolletje rechts opzoeken</p>"},{"location":"Beginnen/","title":"Beginnen met Netherlands3D in Unity","text":"<p>Warning</p> <p>Dit deel van de documentatie is nog gebaseerd op een oudere versie van het project. We werken aan een nieuwe versie  die deze spoedig zal vervangen.</p>"},{"location":"Beginnen/#systeemeisen","title":"Systeemeisen","text":"<p>Een laptop waarop je software mag installeren (nog) geen Apple en het liefst met een i5 CPU (of hoger)  en een externe GPU (grafische kaart). Windows 10 of hoger (in ieder geval 64 bits). Een losse muis om beter te kunnen navigeren.</p>"},{"location":"Beginnen/#git-installeren","title":"Git installeren","text":"<p>Zorg om te beginnen dat Git is geinstalleerd op het systeem. Dit maakt het mogelijk om pakketjes te installeren.</p> <p>Git is te downloaden vanaf https://gitforwindows.org/</p> <p>Installatie met de standaard opties is voldoende. Herstart je systeem na de installatie.</p>"},{"location":"Beginnen/#unity-installeren","title":"Unity installeren","text":"<p>Download en installeer Unity3D via https://unity.com/download</p> <p>Je download daarmee de 'Unity Hub'. Vanuit deze Hub kan je verschillende versies van Unity downloaden.</p> <p>'Sign in' met een bestaand Unity account, of maak eerst een nieuw account aan via 'Create account' en doe dan 'Sign in'</p> <p>Ga eventueel akkoord met het activeren van een 'FREE personal license'.</p> <p>Kies in het 'Install Unity Editor' scherm rechtsonderin 'skip installation'. Wij willen namelijk een specifieke versie gaan installeren.</p> <p>Installeer via 'Installs / Install Editor' de LTS (long term service) versie 2021.3.6f1</p> <p></p> <p>Maak na het installeren in de Hub een nieuw Unity project aan via 'Projects / New Project' en kies als template '3D Core'.</p> <p>Kies een naam voor je project en de locatie op je computer</p> <p></p> <p>Het project wordt vervolgens automatisch geopend in Unity.</p>"},{"location":"Beginnen/#netherlands3d-packages-beschikbaar-maken","title":"Netherlands3D packages beschikbaar maken","text":"<p>Met Netherlands3D worden alle packages gepubliceerd op OpenUPM, een Unity Package  Registry voor Open Source packages.</p> <p>OpenUPM raadt aan om hun CLI tool te gebruiken om packages mee te installeren, maar het is ook mogelijk om deze als Scoped Registry toe te voegen middels de volgende stappen:</p> <ul> <li>open Edit/Project Settings/Package Manager.</li> <li>Voeg een nieuwe Scoped Registry toe, of bewerk de bestaande OpenUPM verwijzing.   <pre><code>Name: package.openupm.com\nURL: https://package.openupm.com\nScope(s): eu.netherlands3d\n</code></pre></li> <li>Klik op Save (of Apply)</li> </ul> <p>Om een overzicht te zien van alle packages die je op deze manier kan installeren volg je deze stappen:</p> <ul> <li>Open de Package Manager</li> <li>In de dropdown <code>Packages: In Project</code>, selecteer <code>My Registries</code></li> </ul> <p>In dit overzicht staan alle packages die beschikbaar vanuit Netherlands3D, en andere Scopes mocht je  die ingesteld hebben staan.</p>"},{"location":"Beginnen/#netherlands3d-opzetten","title":"Netherlands3D opzetten","text":"<p>Open in Unity de package-manager (window package manager)</p> <p></p> <p>Klik op het + icoon in de linkerbovenhoek, kies voor \"Add package from git URL\", vul daar in \"https://github.com/Amsterdam/Netherlands3D.git?path=/Packages/Netherlands3D/\" en klik op \"Add\".</p> <p></p> <p></p> <p>Unity gaat nu even iets voor zichzelf doen.</p> <p>Er komt een melding om de editor opnieuw te starten, klik op Yes</p> <p></p> <p>Unity herstart nu en laat daarna, als alles goed gegaan is, de package Netherlands3D zien in de package-manager.</p> <p></p> <p>Onder het kopje \"Samples\" staat een lijst met pakketjes, dit zijn de modules in netherlands3D die je kunt toevoegen aan je eigen project.</p> <p></p> <p>We beginnen met het TileSystem. Dit is de module die het 3D-model van de stad laat zien.  Klik hiervoor op het knopje \"Import\" naast \"TileSystem\".</p> <p>Unity heeft nu in de Assets map een mapje \"Samples\" aangemaakt met daarin een mapje \"Netherlands3D\" en daarin een mapje met een versienummer. In dit mapje staat alles wat je nodig hebt om het 3D-model van de stad in het project te laten zien.</p> <p>Nu maken we in de Assets map een nieuwe map aan met de naam \"RenderPipeline\" (let op de hoofdletters).</p> <p></p> <p></p> <p>Geef een rechter-muisklik op deze nieuwe map en kies via create &gt; rendering &gt; voor URP Asset (with Universal Renderer).</p> <p></p> <p>Unity geeft je nu de optie om de naam van dit nieuwe bestand te wijzigen, maar dat is niet nodig. Geef een enter om de voorgestelde naam te accepteren. Direct na het accepteren van de bestandnaam maakt Unity nog een tweede bestand aan.</p> <p></p> <p>De laatste handeling die we moeten doen is aan Unity vertellen dat deze, zojuist gemaakt bestandjes, gebruikt moeten worden door de Universal Render Pipeline. Dit doen we in de project Settings ( Edit project Settings. In het project settings menu kiezen we in de linker kolom voor \"Graphics\".)</p> <p></p> <p>Boven in het Graphicsmenu klikken we op het rondje naast het invulveld bij Scriptable Render Pipeline Settings.</p> <p></p> <p>In het menuutje dat opent dubbelklikken we op het bestandje dat we zojuist hebben aangemaakt.</p> <p></p>"},{"location":"Camera/","title":"Bestuurbare Camera","text":"<p>Warning</p> <p>Dit deel van de documentatie is nog gebaseerd op een oudere versie van het project. We werken aan een nieuwe versie  die deze spoedig zal vervangen.</p> <p>Om door de wereld te navigeren hebben we een camera nodig die we zelf kunnen besturen.  Hier hebben we natuurlijk een pakketje voor klaar staan in Netherlands3D.</p> <p>Controleer eerst of je Unity project juist is ingesteld om met invoer om te gaan.</p> <p>Onder \u2018Edit/Project Settings/Player/Other options\u2019 moet \u2018Active input handling\u2019 ingesteld staan op \u2018Both\u2019. </p> <p>Het is mogelijk dat Unity opnieuw moet starten na het toepassen.</p> <p></p> <p>Importeer nu het Netherlands3D voorbeeld \u2018Cameras\u2019 uit de Package Manager:</p> <p></p> <p>*Je kunt de Package Manager boven in Unity vinden onder \u2018Window/Package Manager\u2019</p> <p>Verwijder eerst een eventuele standaard camera uit je eigen scene. Vervolgens kan je FreeCamera en de CameraInputSystemProvider kopieren naar je eigen scene om die camera te gebruiken.</p> <p></p> <p>Druk vervolgens op Play om je scene met de nieuwe camera te testen.</p>"},{"location":"Camera/#camera-bediening","title":"Camera bediening","text":""},{"location":"Camera/#muis","title":"Muis","text":"<ul> <li>Camera verslepen: Klik en slepen Linkermuisknop</li> <li>In- en uitzoomen: Scrollen</li> <li>Draai om punt: Muiswiel indrukken of Alt + Linkermuisknop</li> <li>Rondkijken: Ctrl+Linkermuisknop + slepen</li> </ul>"},{"location":"Camera/#toetsenbord","title":"Toetsenbord","text":"<ul> <li>W of pijl omhoog: Naar voren schuiven</li> <li> <p>S of pijl omlaag: Naar achteren schuiven</p> </li> <li> <p>A of pijl naar links: Naar links schuiven</p> </li> <li>D of pijl naar rechts: Naar rechts schuiven</li> <li>Q: Naar links draaien</li> <li>E: Naar rechts draaien</li> <li>R: Omhoog draaien</li> <li>F: Omlaag draaien</li> <li>PageUp: Camera omhoog bewegen</li> <li>PageDown: Camera omlaag bewegen</li> </ul>"},{"location":"Camera/#gamepad","title":"Gamepad","text":"<ul> <li>Linker Stick: Camera in richting van stick bewegen</li> <li>Rechts Stick: Camera draaien</li> <li>Linker Stick indrukken: Omhoog bewegen</li> <li>Rechter Stick indrukken: Omlaag bewegen</li> </ul>"},{"location":"DataKlaarzetten/","title":"Data Klaarzetten","text":"<p>In de vorige handleiding hebben we een unity-project gemaakt waarin we Amsterdam in 3D zien.  Hartstikke leuk, maar wat moet je doen om een ander gebied te kunnen zien.</p> <p>In deze handleiding gaan we 3D-modellen van gebouwen en terrein bemachtigen en deze voorbereiden voor gebruik in Unity.</p> <p>In de volgende handleiding gaan we het Unity-project zodanig aanpassen dat we dit nieuwe 3D-model kunnen laten zien.</p>"},{"location":"DataKlaarzetten/#gebouwendata-downloaden","title":"Gebouwendata downloaden","text":"<p>De TU Delft heeft voor heel nederland 3D-modellen van (bijna) alle gebouwen in nederland gegenereerd.  Deze modellen kunnen we downloaden en gebruiken.</p> <p>Ga hiervoor naar 3dbag.nl en zoek het knopje \"Downloads\" Op deze pagina kun je een tegel selecteren en vervolgens op \"Confirm Selection\" klikken.</p> <p></p> <p>Op de pagina die vervolgens download je de tegel in cityJSON formaat door op het bestand onder de kop File te klikken.  Let op dat je het bestand kiest dat eindigt op \".json\"</p> <p></p> <p>Vervolgens klik je op \"Pick Another Tile\" totdat je alle tegels binnen het gebied dat je wilt hebben gehad hebt.</p> <p>Alle gedownloade bestanden staan nu waarschijnlijk in de downloads-folder.  Het is aan te raden deze bestanden te verplaatsen naar een nieuwe map.</p>"},{"location":"DataKlaarzetten/#terreindata-downloaden","title":"Terreindata downloaden","text":"<p>Het kadaster heeft voor heel Nederland een terreinmodel gegenereerd op basis van de BGT en luchtfotos en deze beschikbaar gesteld op https://3d.kadaster.nl/basisvoorziening-3d/</p> <p>Eenmaal per jaar wordt er een nieuwe versie gemaakt.</p> <p>In de dataset van luchtfotojaar 2020 zit een probleem waardoor de watervlakken deels ontbreken, wij raden op dit moment aan luchtfotojaar 2019 te gebruiken.</p> <p>Selecteer hier een tegel die je wilt hebben en klik op de download-link achter 3D Basisbestand Volledig.</p> <p></p> <p>Herhaal dit voor alle tegels binnen het gebied waarin je ge\u00efnteresseerd bent.</p> <p>De bestanden die gedownload worden zijn gezipt, dus pak ze uit en plaats alle resulterende .json-bestanden in een aparte map (als het goed is 4 stuks per tegel en een txt bestand).</p>"},{"location":"DataKlaarzetten/#het-omzetten-voorbereiden","title":"Het omzetten voorbereiden","text":"<p>Om de data van de 3dBag en de 3DBasisvoorziening soepel te kunne gebruiken in unity hebben wij een conversietool gemaakt.</p> <p>Om deze tool te downloaden ga je naar https://github.com/Amsterdam/CityDataToBinaryModel/releases</p> <p>Op deze pagina staan alle versies van de tool die ooit gereleased zijn. De bovenste in de lijst heeft altijd het icoontje \"Latest\", deze willen we downloaden.  Dit doen we door onder het kopje \"Assets\" op het zip-bestand te klikken.</p> <p></p> <p>Pak het zip-bestandje uit naar een map die je makkelijk terug kunt vinden.</p> <p>Er staan een heleboel bestanden in deze nieuwe map, maar laat je daar niet door intimideren.  Het enige bestand in deze map die voor het gebruik belangrijk is, is TileBakeTool.exe</p> <p>Om de TilebakeTool te vertellen wat deze precies moet doen hebben we een instellingenbestandje nodig.</p> <p>Voor de 3DBag en 3DBasisvoorziening hebben we deze al voorbereid voor je.</p> <p>Ga naar https://github.com/Amsterdam/CityDataToBinaryModel/tree/main/config</p> <p>Klik op 3Dbasisvoorzieing.json. gihub laat nu de inhoud van dit bestandje zien.</p> <p></p> <p>Klik nu bovenin op \"copy raw contents\", open windows kladblok en plak de inhoud met ctrl+v.</p> <p></p> <p>Vervolgens slaan we dit bestand op onder de naam 3DBasisvoorziening.json</p> <p>Doe hetzelfde voor de bestanden \"panden TUDelftLod1-2.json\" en \"panden TUDelftLod2-2.json\"</p>"},{"location":"DataKlaarzetten/#datasets-omzetten","title":"Datasets omzetten","text":"<p>Om de tilebaketool aan het werk te kunnen zetten hoeven we deze alleen nog maar te vertellen waar de bronbestanden staan en waar de resultaten geplaatst moeten worden. Dit doen wij in het instellingenbestand.</p> <p></p> <p>\"sourceFolder\" verwijst naar de map waarin de gedownloade en uitgepakte bestanden met de terreindata staan.  Let erop dat hier een \"/\" achter de mapnaam geplaatst moet worden.</p> <p>\"outputFolder\" verwijst naar de map waarin de resultaten geplaatst moeten worden, aangevuld met een stuk tekst waarmee de naam van de nieuwe bestanden moet beginnen. In het bovenstaande voorbeeld wordt de output dus geplaatst in de map 'brondata/terreintest/output' op de E-schijf, en alle bestandsnamen in de output beginnen met het voorvoegsel \"Terrein-\".</p> <p>LET OP: 3D-Bassisvoorziening heeft voor de 2019 en de 2020 versies verschillende LOD-niveau benamingen.</p> <p>Voor de 2019-versie moet in het instellingen-bestand bij \"lod :\" 1.0 ingevuld worden, voor de 2020-versie moet dit 1.2 zijn.</p> <p>Wanneer we nu deze instellingen aangepast en opgeslagen hebben kunnen we de tilebaketool aan het werk zetten. Dit doen we op de volgende manier:</p> <p>Open de windows verkenner 2 keer en plaats deze naast elkaar in het scherm.  In de ene verkenner open je de map met het instellingenbestand en in de andere verkenner open je de map met de tilebaketool.</p> <p>Vervolgens klik je op het instellingenbestand, sleep je deze op tilebaketool.exe in de andere verkenner en laat hem los.</p> <p></p> <p>Op dit moment opent er een venster met een zwarte achtergrond, dit is de tilebaketool die vertelt wat hij op dit moment doet.</p> <p></p> <p>Wanneer de Tilebaketool klaar is (voor het maaiveld kan dit enkele uren duren) zijn er in de outputfolder en heleboel bestanden gemaakt.</p> <p>Voor elke vierante kilometer zijn 5 bestanden gegenereerd:</p> <p></p> <p>Het bestand dat eindigt op .bin bevat de geometrie.</p> <p>Het bestand dat eindigt op .bin.br bevat de geometrie, en is gecomprimeerd.  Deze bestanden worden gebruikt als de 3D-viewer in een webbrowser draait.</p> <p>Het bestand dat eindigt op -data.bin bevat data waaruit we kunnen herleiden welke stukjes geometrie bij een uniek object-id horen (bijvoorbeeld een bag-id)</p> <p>Het bestand dat eindigt op .gltf zorgt er voor dat je de geometrie in het .bin-bestand kan openen in paint3D of andere software die gltf-bestanden kan openen.</p> <p>Als bovenstaande allemaal is gelukt kan je de eigen data in Unity gaan koppelen, volg hiervoor de handleiding DataKoppelen.md</p>"},{"location":"DataKoppelen/","title":"Eigen data koppelen in Unity","text":""},{"location":"DataKoppelen/#rd-coordinaat-kiezen","title":"RD-co\u00f6rdinaat kiezen","text":"<p>Om je eigen data te koppelen moet je eerst een relatief RD-co\u00f6rdinaat bepalen binnen je eigen gebied. Het is makkelijk om hiervoor deze website te gebruiken: (https://www.msimons.nl/osm/). Klik hiervoor op een centraal punt binnen je gebied en rond het getal af in het venster rechtsonderin</p> <p></p> <p>kopieer of onthoudt deze getallen, om ze later in Unity in te vullen.</p>"},{"location":"DataKoppelen/#relatief-coordinaat-instellen-in-unity","title":"Relatief co\u00f6rdinaat instellen in Unity","text":"<p>Open je nieuwe project in Unity en zoek in de Hierachy naar 'RDOrigin'. Vul dan het geselecteerde co\u00f6rdinaat in onder tab 'inspector', in bovenstaand geval X 155000 en Y 463000.</p> <p></p>"},{"location":"DataKoppelen/#eigen-data-koppelen-in-unity_1","title":"Eigen data koppelen in Unity","text":"<p>Ga in de verkenner naar het pad waar de eigen data is opgeslagen (dat kan een usb-stick, externe harddisk, of webserver locatie zijn) en kopieer het pad van een voorbeeld \".bin\" bestand.</p> <p></p> <p>en plak deze in de inspector onder het kopje 'Dataset' bij 'Path'</p> <p></p> <p>Wijzig de co\u00f6rdinaten in {x} en {y}, zoals hierboven te zien is en wijzig alle  in /. Selecteer en kopieer deze regel voor een eventueel ander LOD niveau (voor gebouwen en 3D Basisvoorziening 2020)</p> <p>Wijzig dan alleen het lod getal in de regel naar de gewenste.</p> <p>Herhaal deze handeling ook voor de gebouwen (hier zelfs twee keer voor verschillende LOD's) en wanneer alle paden correct zijn ingevuld, kan je op play drukken. Als het goed is zie je dan de terreinen en gebouwen van je eigen gebied in beeld. Het kan zijn dat de camera nog niet helemaal goed staat. Kijk daarvoor in de handleiding 'Camera.md'</p>"},{"location":"Embedding/","title":"Embedding Netherlands3D on Your Website","text":"<p>You can easily embed Netherlands3D on your own website using an iframe. This allows you to showcase the 3D  representation of the Netherlands directly within your web pages. You can also customize the location and features  displayed using a query string.</p>"},{"location":"Embedding/#using-an-iframe","title":"Using an Iframe","text":"<p>To embed Netherlands3D with Rijksdriehoekformaat (EPSG:28992) coordinates, use the following HTML code snippet. Replace the <code>src</code> attribute value with the URL of the Netherlands3D digital twin you'd like to embed:</p> <pre><code>&lt;iframe\n        src=\"https://netherlands3d.eu/twin/?origin=161088,503050,300&amp;features=terrain,buildings,trees,sun\"\n        width=\"640\"\n        height=\"480\"\n        frameborder=\"0\"\n&gt;&lt;/iframe&gt;\n</code></pre> <ul> <li> <p>src: Set this attribute to the URL of the Netherlands3D digital twin. You can customize the location and features   using the query string.</p> </li> <li> <p>width and height: Adjust these attributes to define the dimensions of the iframe on your webpage. Make sure the   width   fits your design, and the height provides an optimal viewing experience.</p> </li> <li> <p>frameborder: Set this attribute to \"0\" to remove the iframe border.</p> </li> </ul>"},{"location":"Embedding/#configuring-location-and-features","title":"Configuring Location and Features","text":"<p>You can customize the location and features displayed in your embedded Netherlands3D using a query string. In the query string, the origin parameter should follow the format <code>origin=X,Y,elevation</code>, where <code>X</code> and <code>Y</code> is the position of the camera in Rijksdriehoekformaat (EPSG:28992) coordinates and elevation is the desired viewing elevation.</p> <p>Here's an example URL with a query string for your reference:</p> <pre><code>https://netherlands3d.eu/twin/?origin=161088,503050,300&amp;features=terrain,buildings,trees,sun\n</code></pre> <ul> <li> <p>origin: This parameter sets the initial view location in the   Rijksdriehoekformaat (EPSG:28992) coordinate system. It follows the format   <code>origin=X,Y,elevation</code>, where elevation is a value between <code>0</code> and <code>1400</code>.</p> </li> <li> <p>features: Use this parameter to specify which features to display in the digital twin. You can include multiple   features, separated by commas.</p> </li> </ul>"},{"location":"Embedding/#using-the-setup-wizard","title":"Using the Setup Wizard","text":"<p>For an even easier way to generate the query string with the desired configuration, you can visit the Netherlands3D Setup Wizard (https://netherlands3d.eu/twin/). This interactive tool allows you to select the location, features, and other options, and it generates the corresponding query string for your iframe.</p> <p>Once you have the query string, insert it into the <code>src</code> attribute of your iframe code, and you'll have a fully customized embedded Netherlands3D digital twin on your website.</p>"},{"location":"Layers/","title":"Layers in Netherlands3D","text":""},{"location":"Layers/#layers","title":"Layers","text":"<p>Layers in Netherlands3D are objects that have an effect on the 3D environment. Layers are hierarchical, similar to GameObjects in Unity. Because of this. the Layer data structure makes use of Unity's GameObject/Transform hierarchy in order to minimize custom coding of the data structure, and to visualize the data structure in the Unity Editor hierarchy.</p>"},{"location":"Layers/#functionality-of-layers","title":"Functionality of layers","text":"<p>All layers have the following basic functionality: - Parenting: This works similar to the Unity Hierarchy. - Reordering: This works similar to changing the sibling index within the same parent in the Unity hierarchy. - Visibility: This works similar to setting a GameObject active/inactive in the Unity hierarchy. - Properties: Each layer can have its own settings specific to the layer type, or even more specific to the content of the layer. This is similar to how the inspector in Unity will display all components and serialized fields of a GameObject.</p> <p>The layer data structure hierarchy is managed by the class <code>LayerData</code>. There should only be 1 LayerData object in the scene.</p>"},{"location":"Layers/#layer-types","title":"Layer types","text":"<p>Layers are split in 2 categories: 1. Regular layers that do not need their own GameObject hierarchy (basic layers) 2. Layers that do require a GameObject hierarchy (referenced layers)</p>"},{"location":"Layers/#basic-layers","title":"Basic layers","text":"<p>The first category of layers is the most simple. These layers are an extension of the <code>LayerNL3DBase</code> class.</p> <ul> <li>Folder layer:</li> </ul> <p>The most simple form of a Layer in this category is a <code>FolderLayer</code>. This layers has no functionality, except for providing the user with a way to organise other layers. It is similar to an empty GameObject.</p> <ul> <li>Polygon selection layer:</li> </ul> <p>A <code>PolygonSelectionLayer</code> is a layer that represents a polygon in the 3D environment. This layer can be created by providing a <code>List&lt;Vector3&gt;</code> of points (either by user input or from another source). This will create a layer in the hierarchy, with a visualisation that will listen to user input so that the layer can be selected by the user by clicking on the visualisation in the scene.</p>"},{"location":"Layers/#referenced-layers","title":"Referenced layers","text":"<p>In case a layer has an internal hierarchy (such as a hierarchy of object parts, or a container with different tile objects) a layer can be integrated in the layer system as a referenced layer. A referenced layer exists outside of the Layer data structure, but has a connection to it through a <code>ReferencedProxyLayer</code> . The ReferencedProxyLayer will pass the required actions that affect the layer to its reference outside of the layer hierarchy, thereby making the referenced layer comply with the layer functionalities. In order to do this, the layer object outside of the hierarchy must have an extension of the abstract class <code>ReferencedLayer</code> attached to it. This class will automatically create the <code>ReferencedProxyLayer</code>, thereby creating the connection to the layer system.</p> <p>The following Layers are referenced layers: * Hierarchical object layer:</p> <p>A <code>HierarchicalObjectLayer</code> is an object that can be placed in the 3D environment. By default, this object can be moved by the transform handles. Objects of this type either come from a library of developer defined objects, or by user uploads. The most simple Hierarchical object layer is a GameObject with a <code>MeshFilter</code>, <code>MeshRenderer</code>, <code>Collider</code>, and <code>HierarchicalObjectLayer</code> component attached. More complex Hierarchical object layers can have nested GameObjects with each their own internal logic.</p> <ul> <li>Cartesian tile layer:</li> </ul> <p>A <code>CartesianTileLayer</code> is a layer that makes use of the Netherlands3D custom tile file format. The objects and tiles in the layer are managed by the <code>TileHandler</code> and through the class <code>CartesianTileLayer</code> can interact with the layer system. For more information see the section on Cartesian Tiles. </p> <ul> <li>3D tile layer:</li> </ul> <p>A <code>Tile3DLayer2</code> is a layer that makes use of the 3D Tiles file format. These layers are managed by <code>Read3DTileset</code> and through the class <code>Tile3DLayer2</code> can interact with the layer system. For more information see the section on 3D Tiles. </p> <ul> <li>Object scatter layer:</li> </ul> <p>An <code>ObjectScatterLayer</code> is a special type of layer that will scatter the combined mesh of a <code>HierarchicalObjectLayer</code> in the area defined by a <code>PolygonLayer</code>. To do this, create a <code>PolygonLayer</code> and make a <code>HierarchicalObjectLayer</code> the child of the <code>PolygonLayer</code>. This will convert the <code>HierarchicalObjectLayer</code> to an <code>ObjectScatterLayer</code>. Unparenting the ObjectScatterLayer from a PolygonLayer will revert the layer back to a <code>HierarchicalObjectLayer</code>. The <code>ObjectScatterLayer</code> has scatter settings that determine how the scattering should occur. </p> <p>Warning</p> <p>The scattering is achieved through GPUInstancing, and therefore the mesh and material should support this. All objects in the ObjectLibrary support scattering.</p>"},{"location":"Layers/#layer-ui","title":"Layer UI","text":"<p>Each Layer can have an associated UI component defined by the class <code>LayerUI</code>. This component controls the UI elements associated with the layer. Interacting with the LayerUI will affect the corresponding <code>LayerNL3DBase</code>. The Layer UI hierarcy is managed by <code>LayerManager</code>. This class holds a references to the layer type icons that are requested by LayerUI.</p>"},{"location":"Layers/#creating-your-own-layers-of-an-existing-type","title":"Creating your own layers of an existing type","text":"<p>In order to add one of your own layers as an option through the existing UI, the following steps should be followed: 1. Create a prefab with the layer object. Make sure this object has a component of either <code>LayerNL3DBase</code> or <code>ReferencedLayer</code> attached to it. 2. Instantiate the prefab. If this is done in the existing LayerPanel UI, add a button or toggle in the prefab <code>AddLayerPanel.prefab</code> in the appropriate panel sub section. Then have the script that controls the button or toggle logic instantiate the prefab made in step 1.</p>"},{"location":"Layers/#creating-your-own-layers-of-a-new-type","title":"Creating your own layers of a new type","text":"<p>Follow the following steps to create a new layer type: 1. Choose if the new layer type can be a simple layer (direct extension of <code>LayerNL3DBase</code>) or it needs to be a more complex referenced layer (extension of <code>ReferencedLayer</code>). 2. Extend the chosen class and implement the required methods. 3. Add your own logic to the new class 4. Add a reference to the appropriate type and icon in LayerManager to ensure the new layer does not use the default <code>?</code> icon.</p>"},{"location":"Layers/#layers-and-functionalities","title":"Layers and Functionalities","text":"<p>Specific layers or specific types of layers can also be enabled/disabled with the functionalities system. Follow these steps to do this: 1. Add a <code>FunctionalityListener</code> to the prefab of the layer. Add the functionality you want to link the layer to, and in the <code>OnDisableFunctionality</code> event, add a function that will destroy the gameObject itself. This will clean up any active layers when disabling the functionality. 2. For any buttons that instantiate the prefab above, add a <code>FunctionalityListener</code> to the button that will enable/disable the button's gameObject when the functionality is enabled/disabled respectively. This will ensure the user cannot instantiate layers from functionalities that are disabled. 3. (Optional) In case your layers should by default spawn when the functionality is enabled, add a PrefabSpawner script to the scene where the functionality and the associated prefab are set in the inspector.</p>"},{"location":"SelectionTools/","title":"SelectionTools (Geavanceerde gebruikers)","text":"<p>Het 'SelectionTools' pakket bied enkele voorbeelden om gebieden of lijnen te selecteren door met de muis te tekenen. Deze tool is bedoeld voor geavanceerde Netherlands3D gebruikers met Unity ervaring. Deze tools kunnen gebruikt worden om, als voorbeeld, API's te bevragen met boundingbox of polygoon queries.</p>"},{"location":"SelectionTools/#rechthoekig-gebied-selecteren","title":"Rechthoekig gebied selecteren","text":"<p>Om een rechthoeking gebied te selecteren gebruik je de AreaSelection tool, te vinden in de voorbeeldscene 'AreaSelection'</p> <p>Om deze tool samen te laten werken met de FreeCamera moet **Shift ** ingedrukt worden om vervolgens met de klik+sleep actie van de muis de selectie te maken. (Shift blokkeert de sleepactie van de camera)</p> <p>De output van dit systeem is vervolgens een event met een Bounds object. In het voorbeeld wordt deze omgezet naar een RD boundingbox zoals deze vaak gebruikt wordt in API's, en in beeld getoond als tekst:</p> <p>bbox=120700,486800,121200,487200</p>"},{"location":"SelectionTools/#polygoon-selecteren","title":"Polygoon selecteren","text":"<p>De voorbeeldscenes PolygonSelection en PolygonSelection_WithHandles laten een voorbeeld zien van het PolygonSelection systeem waarmee een gebruiker met een muisklik punten kan plaatsen om zo de lijn van een polygoon te tekenen.</p> <p>De scenes gebruiken dezelfde tool, alleen is bij de 'WithHandles' scene de mogelijkheid om handles (handgrepen) te plaatsen bij het plaatsen van punten ingeschakeld. Deze handles maken het mogelijk om de lijn van de polygoon te 'finetunen' door de punten te verschuiven na het tekenen van de vorm.</p> <p>De output van het PolygonSelection systeem is een event met een Vector3 List. Deze lijst bevat alle coordinaten van de punten in de volgorde hoe deze geplaatst zijn.  Met de 'Winding Order' kan deze lijst op volgorde gezet worden zodat de punten met de klok mee lopen, of juist tegen de klok in.</p> <p>Met twee losse events voor 'Selected Polygon Area' en 'LineHasChanged' kan de lijst verstuurd worden bij het plaatsen van een punt, en/of bij het afronden/sluiten van de vorm of lijn.</p>"},{"location":"SelectionTools/#lijn-plaatsen","title":"Lijn plaatsen","text":"<p>HetPolygonSelection systeem kan ook niet-gesloten polygonen tekenen. In dat geval hebben we het over een lijn. Door 'Require Closed Polygon' uit te zetten kan een polygoon afgerond worden met **Enter ** zonder dat deze afgesloten wordt.</p>"},{"location":"TileSystemGebruiken/","title":"TileSystem gebruiken","text":"<p>Om het TileSystem in actie te zien gaan we in de assetsFolder naar de eerder geimporteerde Sample. In deze sample openen we de map \"Scenes\".</p> <p></p> <p>Vervolgens slepen we het bestand \"LoadLayersFromScene\" naar de hierarchy.</p> <p></p> <p>Om een goed beeld te kunnen krijgen willen we de Main Camera nog even verplaatsen. Dit doen we door in de Hierarchy de Main Camera aan te klikken:</p> <p></p> <p>En vervolgens in de inspector de Position en Rotation aan te passen.</p> <p></p> <p>Nu we toch in de Inspector voor de camera bezig zijn zetten we ook onder het kopje \"Camera\", \"Projection\", \"Clipping plane\" de afstand voor Far even van 1000 op 6000.</p> <p>Klik vervolgens op \"Play\", et voila, we zien het 3D-model van Amsterdam.</p> <p>Je bent nu klaar om met de volgende stap te beginnen \"het koppelen van je eigen dataset\", volg hiervoor de handleiding 'DataKlaarzetten.md'</p>"},{"location":"WMSLagen/","title":"WMS functionaliteiten toevoegen","text":""},{"location":"WMSLagen/#werkwijze","title":"Werkwijze","text":"<p>We hebben de mogelijkheid gebouwd om WMS services (pixel gebaseerde api) binnen Netherlands 3D in te laden. Hiervoor is de sample WMS-layer beschikbaar in de package. Importeer deze en sleep de map op de assets map in Unity (hiermee voorkom je dat bij updates de laag en eigen instellingen wordt overschreven).</p> <p></p> <p>Ga naar de map scenes en sleep onderstaande scene in de hierarchy</p> <p></p> <p></p> <p>Sleep vervolgens de items uit het Canvas van de ingesleepte scene, naar het canvas in de hoofdscene. Doet dit ook met de wmsLayerManager, maar sleep deze in de root.</p> <p></p> <p>Het enige wat nu nog moet gebeuren is de Renderpipeline instellingen wijzigen. Open de project settings via het edit menu van Unity.</p> <p></p> <p>En zoek naar de graphics instellingen.</p> <p></p> <p>Klik op het bolletje helemaal rechts en kies voor de UniversalRP-HighQuality pipeline asset.</p> <p>Sluit dit venster en probeer de functie uit door op play te drukken.</p>"},{"location":"Zonnestand/","title":"Zonnestand + Shaduwen","text":"<p>Het Netherlands3D pakketje bevat een voorbeeld om de zonnestand en schaduwen te laten bepalen aan de hand van een locatie en de datum/tijd.</p> <p>Importeer het voorbeeld vanuit de Package Manager: Je kunt de Package Manager boven in Unity vinden onder \u2018Window/Package Manager\u2019*</p> <p></p> <p>De voorbeeld scene heeft een prefab met de naam \u2018Sun\u2019. Deze bevat het script SunTime waarmee je de locatie en tijd kan instellen.  Stel de GPS locatie van dit script in via de Inspector:</p> <p></p> <p>Het Canvas in de Scene laat een voorbeeld interface zien waarmee een gebruiker de tijd en animatie snelheid kan aanpassen. Je kan de Sun prefab kopieren naar je eigen scene. Zorg er wel voor dat je een eventueel bestaand \u2018Directional Light\u2019 verwijder uit je scene.  De Directional Light in de Sun prefab gaat namelijk zorgen voor de belichting en schaduwen. Wanneer je ook het stukje interface wil gebruiken kan je ook het Canvas en EventSystem naar je eigen scene kopieren.</p>"},{"location":"developers/basis-in-een-uur/","title":"Basis in een uur","text":"<p>Warning</p> <p>Dit deel van de documentatie is nog gebaseerd op een oudere versie van het project. We werken aan een nieuwe versie  die deze spoedig zal vervangen.</p> <p>Naast het beginnen vanaf een nieuw project om daar samples van de package in te laden, bieden we nu ook een basis layout aan, waar de volgende samples uit de package al in zitten:</p> <ul> <li>Freecamera</li> <li>Sun</li> <li>Tilehandler</li> <li>BAGBuildingDataLoader</li> <li>BAGResidenceDataLoader</li> <li>wmsLayerManager</li> <li>Eenvoudige layout met canvas Group voor automatisch uitlijnen vensters</li> <li>plek voor eigen logo</li> </ul>"},{"location":"developers/basis-in-een-uur/#repository-opzetten","title":"Repository opzetten","text":"<p>Hiervoor heb je een git-client nodig, zoals tortoise (uitgebreid) of Github Desktop (eenvoudig). download en installeer \u00e9\u00e9n van deze en ga naar de website waar je repositories kan maken (in dit geval Gitlab).</p> <p>Maak een nieuwe repository aan.</p> <p></p> <p>New project/repository</p> <p>Klik op blank project.</p> <p></p> <p>Vul hier een project naam en andere gegevens in....let op dat je in ieder geval een README file aanvinkt. Public of private is een eigen keus, maar de beste is natuurlijk public (om deze reden is Netherlands 3D ook public).</p> <p></p> <p>Klik op create project en we zijn zover dat we de (cloud) omgeving kunnen gaan clonen naar je lokale machine.</p> <p></p> <p>In mijn geval gebruik in de SSH versie, omdat ik een Putty-key ge\u00efnstalleerd heb (extra beveiligingssleutel, zodat je weet dat je alleen van deze site iets up- of download). Klik op \"copy URL\" en ga naar een verkenner in windows op de plek waar je de lokale repository wilt plaatsen.</p> <p>\"Deze handleiding volgt de Tortoise manier\"</p> <p>Klik met de rechtermuisknop op je verkenner en kies bij Tortoise voor \"clone\"</p> <p></p> <p>en stel de juiste namen in het venster in. \"omdat ik SSH gebruik heb ik hier load Putty Key aangevinkt\"</p> <p></p> <p>klik op OK en de lokale repository wordt gebouwd.</p> <p>Ga naar deze website Gitlab (donor repository) en klik op download source code.</p> <p></p> <p>Pak de inhoud van map \"nwv-main\" uit in de map utr_netherland3d en ga naar de map in verkenner.</p> <p>Vanaf nu wordt het interessant.</p> <p>\"Wat we nu gaan doen is de computer vertellen (aan de hand van een eerder gemaakte repository die we als donor gebruiken) welke mappen/bestanden wel en niet meegaan naar de online omgeving. Dit scheelt heel veel tijd en MB's. Geen zorgen dit gaat alleen om bestanden die Unity nodig heeft om te draaien, niet voor wijzigingen in het project.\"</p> <p>Allereerst voegen we het bestand \".gitignore\" toe aan de cloud repositiory.</p> <p>\"LET OP! Deze handeling is de basis van het werken met Repositories.\"</p> <p>Ga naar de repository (in verkenner) en zoek met rechtermuisknop naar \"tortoise\" en \"commit\"</p> <p></p> <p>voeg een message toe (anders kan je niet committen) en klik met rechtermuis op gitignore om het bestand aan de repo toe te voegen.</p> <p>\"Het bestand \"README.md\" wordt direct meegenomen, omdat deze al in de repository bestond en is gewijzigd bij het kopi\u00ebren van de data uit de donormap.\"</p> <p></p> <p>Klik vervolgens op op commit en daarna op push om het bestandje ook daarwerkelijk te uploaden.</p> <p></p> <p>Klik op ok in het volgende venster. \"Local\" en \"Remote\" staan allebei op main.</p> <p></p> <p>\"commit is zeg maar, het toevoegen van bestanden aan een database en push en pull zijn commando's voor het up- en downloaden van bestanden die in de database voorkomen\"</p>"},{"location":"developers/basis-in-een-uur/#project-laden-met-data-donor-repository","title":"Project laden met data donor repository","text":"<p>Nu gaan we een nieuw project maken in Unity hub.</p> <p>Maak na het installeren in de Hub een nieuw Unity project aan via 'Projects / New Project' en kies als template '3D (URP) Core'.</p> <p>Kies de eerder gemaakte map voor de repository basis.</p> <p></p> <p>Het project wordt vervolgens automatisch geopend in Unity.</p> <p>Nu kunnen we de mappen \"Assets\", \"Packages\", \"ProjectSettings\" en \"UserSettings\" kopi\u00ebren uit de zip file naar de project map.</p> <p></p> <p></p> <p>Ga weer naar de Unity omgeving en zoek in de scene map naar de scene NWV. Open deze en klik met de rechtermuis op de naam in de Hierarchy en kies voor \"Save Scene As\" kies een naam (in dit geval Utrecht) en zet de Scene in de map \"Scenes\"</p> <p></p> <p>Nu kan de donorscene weggegooid worden.</p> <p></p> <p>Controleer of de scene werkt door op play te drukken. Er verschijnen dan tegels van NoordWestVeluwe, maar dat fixen we in de volgende paragraaf. Sluit de play mode weer af.</p> <p>De enige stap is nog om lighting instellingen goed te zetten.</p> <p>Klik op \"Window\" en \"Rendering\" en kies voor \"lighting\"</p> <p></p> <p>Kies daarna voor \"New Lighting Settings\". Unity maakt dan een light setting aan die gebruikt wordt in de playmode.</p> <p></p> <p>Als je dit hebt gedaan klik dan op het tabje \"Environment\"</p> <p></p> <p>Klik op het rondje rechts van \"Sun Source\" en kies in \"Scene\" voor \"Directional Light\"</p> <p></p>"},{"location":"developers/basis-in-een-uur/#eigen-data-koppelen","title":"Eigen Data koppelen","text":"<p>De scene werkt nu met gegevens voor NoordwestVeluwe, maar je wilt natuurlijk eigen data koppelen. Hiervoor kunnen we weer gebruik maken van de handleiding Datakoppelen.md</p>"},{"location":"developers/packages/creating-and-managing-packages/","title":"Creating and managing Packages","text":"<p>Netherlands3D is a framework where you, as developer, can pick the functionality that you need from a series of  packages. This guide will empower you to develop your own packages by providing step-by-step instructions how you can create your own package, release it and last, but not least, publish it to OpenUPM.</p>"},{"location":"developers/packages/creating-and-managing-packages/#variables-placeholders","title":"Variables / Placeholders","text":"<p>Before we get started, let's define some terms as if they were variables. This documentation and the template files  in the Gist mentioned in the chapter Creating a new package uses various placeholders. These  can recognized as they are between brackets, for example <code>{NAME}</code>. </p> <p>This table provides an overview of them and their meaning.</p> Name Explanation Example NAME The name of the code repository, this is usually the DISPLAY_NAME in PascalCase. It is recommended to limit the name to two words, if more words add clarity than that takes precedence. PeriodicSnapshots PACKAGE_NAME The package name as known in the package manager and/or package.json; always starts with <code>eu.netherlands3d.</code> and followed by the display name -or similar- in kebab-case eu.netherlands3d.periodic-snapshots DISPLAY_NAME The human-readable name of a package, shown in the README or in the Package Manager Periodic Snapshots REPOSITORY_NAME Alias of NAME, used to make explicit that we want the repository name there. PeriodicSnapshots VERSION The version number in the package.json, according to SemVer. Important: contrary to the git tag, this does not start with a letter <code>v</code> 1.0.1 DESCRIPTION A single-line short description describing the package, can also be used on Github as the description for the repository This package provides the means to do take a series of snapshots for specific moments throughout the year. LONG_DESCRIPTION The description of the package detailing what it is used for. USAGE_INFORMATION Documentation how to use this package. See existing packages for examples NOTE One or more entries in the CHANGELOG -according to Keep A Changelog- describing what has been added, changed, removed or deprecated in a package <p>This vocabulary and their definitions will help to have a consistent experience when working with packages.</p>"},{"location":"developers/packages/creating-and-managing-packages/#creating-a-new-package","title":"Creating a new package","text":"<p>When creating a new package, it is recommended to first create it as an embedded package in the  Netherlands3D twin project. This will help to prototype and experiment until  the point where it is stable enough to be distributed.</p> <p>This can be done using the following steps:</p> <ol> <li> <p>Clone the Netherlands3D Twin project, located at https://github.com/Netherlands3D/twin.</p> </li> <li> <p>Make sure Unity is not open while performing the following steps; it generally tends to crash when it updates while setting up a package.</p> </li> <li> <p>Create a directory for your embedded package in the     <code>Packages</code> folder.</p> <p>Important</p> <p>The directory name MUST follow the structure <code>eu.netherlands3d.[name]</code> where <code>name</code> is in lower-case kebab-case.</p> </li> <li> <p>Copy the template files, located at https://gist.github.com/mvriel/8a8251b492d9d8f742da16667c49e412, and fill in the placeholders.</p> </li> <li> <p>Set up the package according to the following recommended directory structure: https://docs.unity3d.com/Manual/cus-layout.html</p> </li> <li> <p>Start Unity and allow for it to install the new package, you should see your new package in the \"Installed Packages\" section of the Package Manager with the tag <code>Custom</code> behind the name.</p> </li> <li> <p>When you want to add Scripts to this package: Make sure you have created the folder <code>Runtime\\Scripts</code> as a location to store them and add an Assembly Definition with the name <code>{PACKAGE_NAME}.Runtime</code>. </p> </li> </ol>"},{"location":"developers/packages/creating-and-managing-packages/#promoting-an-embedded-package","title":"Promoting an embedded package","text":"<p>It takes time and effort to get a package into a usable and moderately stable condition. Because of this the recommended way of working is to first create an embedded package in the Twin project -like an incubator project- and once it is  moderately stable: promote it to its own repository.</p> <p>Promoting an embedded package is done by one of the project maintainers -if not alone for the fact that a repository  needs to be made- and follows the following sequence of steps:</p> <ol> <li> <p>Create a repository whose name matches the <code>{NAME}</code> placeholder, thus a PascalCase representation of the     human-readable name.</p> </li> <li> <p>Move all files from the <code>Packages\\{PACKAGE_NAME}</code> folder in the Twin repository to the newly made repository's root     folder</p> </li> <li> <p>Check and adjust, at least, the URL's for the LICENSE, README and CHANGELOG in the <code>package.json</code>.</p> </li> <li> <p>Release and publish the promoted package, see the chapters on releasing and     publishing for the involved steps.</p> </li> <li> <p>In the Twin project, add a reference to <code>{PACKAGE_NAME}</code> to the package.json or install the package through    the package manager.</p> <p>Important</p> <p>After a package is added to OpenUPM for the first time, it can take between 30 and 60 minutes for it to  show up in the package listing.</p> </li> </ol> <p>Once a package is promoted, you can no longer edit it as part of the Twin project; in the next chapter  Changing a Package it is described how you can change a promoted package without all too much  hassle.</p>"},{"location":"developers/packages/creating-and-managing-packages/#changing-a-package","title":"Changing a package","text":"<p>To be written</p>"},{"location":"developers/packages/creating-and-managing-packages/#releasing-a-package","title":"Releasing a package","text":"<p>When you want to release a new version of a package you generally go through the following steps:</p> <p>Tip</p> <p>Before releasing, make sure you have tested your package in the Twin -or  another Netherlands3D-based project- installed as a local package.</p> <p>Especially important is:</p> <ul> <li>verifying that the correct dependencies are set and installed</li> <li>that the Assembly Definition can be used and</li> <li>that the Assembly Definition does not depend on Assembly Definitions that are not a dependency of your package,   especially Netherlands3D.Core.Runtime should be avoided</li> </ul> <p>Failure to do so may cause extra work because once a package is released, it is impossible to change something in the release and a new release must be made.</p> <ol> <li> <p>Go to the repository of your package. If there is none: see the chapter on     Promoting an embedded package and do that first.</p> </li> <li> <p>Ensure the version number in the package.json is updated</p> </li> <li> <p>Check the CHANGELOG.md: </p> </li> <li> <p>Does it contain all changes since the last version?</p> </li> <li> <p>Is the top-entry <code>[Unreleased]</code>? Fill in the new version number and add a date, see: https://keepachangelog.com/en/1.0.0/#effort</p> </li> <li> <p>Ensure any changes in the above are in the main branch</p> </li> <li> <p>Go to \"Releases\" on Github (<code>https://github.com/Netherlands3D/{NAME}/releases</code>) and</p> </li> <li> <p>Draft a new release       </p> </li> <li>Click on \"Choose a tag\"</li> <li>Enter the version number from the package.json with a preceding letter <code>v</code>, for example: <code>v1.0.1</code>.</li> <li>Click on the option \"Create new tag: <code>v{VERSION}</code> on publish\"</li> <li>(optional) Add a release title and description</li> <li>Click on the button \"Publish Release\"</li> </ol> <p>Once a new release/tag has been made, your new release of your package is all set! If it has already been  published on OpenUPM before, no further action is needed. OpenUPM will automatically pick up on the new tag and make the new version available.</p> <p>When the package has not been published on OpenUPM yet, now is a good time to do it.</p>"},{"location":"developers/packages/creating-and-managing-packages/#publishing-a-package-on-openupm","title":"Publishing a package on OpenUPM","text":"<p>When a package is released for the first time, it needs to be published by registering it on OpenUPM.</p> <p>Tip</p> <p>Before publishing, make sure you have tested your package in https://github.com/Netherlands3D/twin -or another Netherlands3D-based project- installed as a local package.</p> <p>Especially important is:</p> <ul> <li>verifying that the correct dependencies are set and installed</li> <li>that the Assembly Definition can be used and </li> <li>that the Assembly Definition does not depend on Assembly Definitions that are not a dependency of your package,   especially Netherlands3D.Core.Runtime should be avoided</li> </ul> <p>Failure to do so may cause extra work because once a package is published, it is inconvenient to unpublish it or  change publication details such as the name.</p> <p>To do so, you can take the following steps:</p> <ol> <li> <p>Go to https://openupm.com.</p> </li> <li> <p>Click on the \"+\" button in the menu bar to add a new package    </p> </li> <li> <p>Fill out the Github repository name in the intended field and click on \"Go\".        A form expands where you can verify the package name, ReadMe location and more</p> </li> <li> <p>Enter your github username in the \"Discovered by\" field; this is used to base a fork of OpenUPM from and add the     package as a pull request.</p> <p></p> <p>Note</p> <p>The section \"Advanced\" is for advanced use when multiple packages are hosted in the same repository; at the moment this method is not recommended and as such that part of the submission form can be skipped</p> </li> <li> <p>Check the \"Promotion\" section if the package fits any of these categories, and check these.</p> </li> <li> <p>Click on the \"Verify Package\" button, all other fields can be left unchanged.</p> </li> </ol> <p>As soon as the steps above have completed, you are asked to fork the <code>OpenUPM</code> repository and to commit these changes in a feature branch. At this point you can use the \"Create pull request\" button to create a pull request to OpenUPM.</p> <p>Tip</p> <p>If this is your first time submitting a package to OpenUPM, the maintainer of OpenUPM needs to approve the Pull  Request manually; this is generally done within 24 hours. Any subsequent pull requests will be automatically merged.</p> <p>After the pull request is merged, it will take 30 to 60 minutes for <code>OpenUPM</code> to add the package to the registry.</p>"},{"location":"developers/packages/creating-and-managing-packages/#faq","title":"FAQ","text":"<p>Can I depend on the <code>Netherlands3D.Core.Runtime</code> assembly?</p> <p>At time of writing, this assembly is within the code of the https://github.com/Amsterdam/Netherlands3D skeleton; meaning that this dependency only works when the package is used within a project that is based on this skeleton. This can be a problematic dependency since we are actively working on moving the contents of this skeleton into components.</p> <p>Because of the above, it is not recommended for a published package to depend on the <code>Netherlands3D.Core.Runtime</code> assembly.</p> <p>If code from this assembly is needed, it is recommended to extract this code into another package that you can depend  on or duplicate it into your own package until such a package can be made.</p> <p>For more information on this, see the question <code>Can I depend on Assemblies that are not in my own package?</code>.</p> <p>Can I depend on Assemblies that are not in my own package?</p> <p>You sure can! As long as these assemblies are in a package that is published in a Unity Package Registry such as  OpenUPM, and that you have added that package as a dependency to your <code>package.json</code> file.</p> <p>If you add an assembly whose package cannot be included in your <code>package.json</code> -either because it is not a package or a git-based package- then you will need to add installation instructions in the README. Without these instructions, any user of the package will have a missing assembly -and thus errors- without knowing how to fix it.</p> <p>One of the packages does not show up in the Package Manager after publishing</p> <p>Have you checked the minimum unity version in the <code>package.json</code>? If the minimum version is newer than your installed version, it will not be visible.</p> <p>Why OpenUPM and not add packages through a Git URL?</p> <p>Good question! When you add packages through a Git URL you lose certain features that packages hosted on a registry do have. This includes but is not limited to:</p> <ol> <li> <p>Unable to update to a new version: when you use a Git tag/release, then you need to uninstall and reinstall the     package when a new becomes available instead of just using the <code>Update</code> button.</p> </li> <li> <p>Git-url based packages cannot be used as dependencies: this means that if a package depends on another, with git     urls you need to manually install the correct dependencies and face possible version conflicts with newer versions.</p> </li> </ol>"},{"location":"developers/ui/introduction/","title":"Introduction","text":"<p>Welcome to the foundational section of our technical documentation, where we introduce the user interface (UI) design system of Netherlands3D. This documentation is crafted to guide developers, designers, and contributors through the  design architecture that shapes the user experience within our digital twin environment.</p>"},{"location":"developers/ui/introduction/#purpose-of-the-design-system","title":"Purpose of the Design System","text":"<p>The design system serves as a comprehensive framework that harmonizes UI design and development, ensuring consistency, scalability, and efficiency across the application. It is the blueprint that orchestrates the visual and interactive elements, making the digital twin not only a technological marvel but also an intuitive and engaging experience for users.</p>"},{"location":"developers/ui/introduction/#overview-of-the-ui-design-system","title":"Overview of the UI Design System","text":"<p>At the heart of our UI design system are two fundamental concepts: Blocks and Components. These elements are the building blocks of our application's interface, structured to offer clarity and flexibility in design and implementation. Inspired by the BEM (Block, Element, Modifier) methodology, our system disambiguates between blocks and components to streamline the development process and enhance the UI's modularity and reusability.</p>"},{"location":"developers/ui/introduction/#blocks","title":"Blocks","text":"<p>Blocks are the larger, more general sections of the UI that function as the containers for components. They define the structural layout and set the stage for the detailed elements within. Blocks can be as broad as the entire application window or as specific as a user interaction panel.</p>"},{"location":"developers/ui/introduction/#components","title":"Components","text":"<p>Components, on the other hand, are the more granular, reusable elements that reside within blocks. They are the nuts and bolts of the UI, encompassing buttons, sliders, text fields, and other interactive elements. Components are designed with flexibility in mind, allowing them to be adapted and reused across different blocks.</p>"},{"location":"developers/ui/introduction/#objectives-of-this-documentation","title":"Objectives of This Documentation","text":"<p>The subsequent chapters of this documentation are dedicated to diving deeper into the specifics of blocks and components, outlining their characteristics, how they are designed, and how they interact within the UI framework of our digital twin platform. Our goals are to:</p> <ul> <li>Clarify the distinction between blocks and components, providing a clear understanding of their roles within the   UI design system.</li> <li>Guide the design and development process, offering insights into best practices for creating and integrating   blocks and components.</li> <li>Facilitate scalability and customization, enabling developers and designers to extend the UI efficiently and   creatively.</li> </ul> <p>As we proceed, this documentation will serve as a reference for enhancing and expanding the user interface of  Netherlands3D, ensuring that the developers and designers within the ecosystem are aligned.</p> <p>In the next chapter, we will explore the concept of blocks in detail, examining their structure, functionality, and how they contribute to the overall user experience of the application.</p>"},{"location":"developers/ui/keeping-our-documentation-current/","title":"Keeping Our Documentation Current","text":"<p>Important Note: While we strive to maintain this documentation as the definitive guide to our UI design system, the realm of digital development is one of constant evolution. To accommodate this, we ensure that the most up-to-date design resources and UI guidelines are housed in an internal Figma board. This board is regularly updated to reflect the latest design decisions, component updates, and UI patterns adopted by our team.</p>"},{"location":"developers/ui/keeping-our-documentation-current/#accessing-the-latest-information","title":"Accessing the Latest Information","text":"<p>For the most current design specifications and UI elements, we encourage team members to refer to our internal Figma board. This resource is designed to be a living document, offering real-time updates and insights into our UI design strategy.</p>"},{"location":"developers/ui/keeping-our-documentation-current/#requesting-documentation-updates","title":"Requesting Documentation Updates","text":"<p>We understand that despite our best efforts, there may be instances where this documentation does not fully capture the latest UI developments or design nuances. In such cases, we welcome requests for documentation updates.</p> <p>By fostering a culture of continuous improvement and open communication, we aim to ensure that our UI design system supports the dynamic needs of our project and team. Whether you're a developer, a designer, or a project stakeholder, your contributions and feedback are invaluable to the ongoing refinement of Netherlands3D.</p>"},{"location":"developers/ui/understanding-blocks/","title":"Understanding Blocks","text":"<p>In the Netherlands3D platform, our design system is structured for clear organization and effective scaling. Blocks form the fundamental part of this structure, acting as the primary containers for the interface's elements. This chapter focuses on blocks, explaining their purpose, features, and their role in creating a unified user experience in Netherlands3D.</p>"},{"location":"developers/ui/understanding-blocks/#what-are-blocks","title":"What Are Blocks?","text":"<p>Blocks are the large-scale elements of our UI design system. They serve as the main sections that organize and contain various components. Think of blocks as the framework of a building, providing structure and defining the layout within our digital environment. In Netherlands3D, blocks have specific functions, such as guiding navigation, displaying information, facilitating user interactions, or showcasing data visually.</p>"},{"location":"developers/ui/understanding-blocks/#features-of-blocks","title":"Features of Blocks","text":"<ul> <li> <p>Modular: Blocks are designed as self-contained units that can be mixed and matched in different layouts, offering   flexibility and reuse across the platform.</p> </li> <li> <p>Scalable: They are built to support the platform's growth, making it easy to add new features or adapt to changing   user needs without disrupting the existing design.</p> </li> <li> <p>Consistent: Despite their variety, blocks maintain a unified design language and user experience across   Netherlands3D.</p> </li> </ul>"},{"location":"developers/ui/understanding-blocks/#designing-blocks","title":"Designing Blocks","text":"<p>Creating blocks for Netherlands3D requires attention to:</p> <ul> <li> <p>User Needs: Design each block with the user's requirements in mind, ensuring it fulfills its intended purpose   effectively.</p> </li> <li> <p>Adaptability: Make blocks adaptable for different types of content and scenarios within the platform.</p> </li> </ul>"},{"location":"developers/ui/understanding-blocks/#managing-blocks","title":"Managing Blocks","text":"<p>The evolution of Netherlands3D involves regular updates to blocks, including additions, removals, or modifications. This process entails:</p> <ol> <li> <p>Planning: Identifying the need based on user feedback or new functionalities.</p> </li> <li> <p>Design and Development: Crafting the block to fit Netherlands3D's design norms and technical specifications.</p> </li> <li> <p>Testing: Ensuring compatibility and performance across devices.</p> </li> <li> <p>Implementation: Incorporating the block into Netherlands3D and monitoring its effectiveness.</p> </li> </ol>"},{"location":"developers/ui/understanding-blocks/#distinction-between-blocks-and-components","title":"Distinction Between Blocks and Components","text":"<p>Blocks and components are fundamental elements of the Netherlands3D UI, but they serve distinct purposes.</p> <p>Blocks are the overarching sections that structure and organize the user interface, similar to the chapters in a book. They are designed for flexibility, accommodating a variety of components to fulfill different functionalities within the platform. Blocks ensure a consistent layout and design language across Netherlands3D, providing a cohesive user experience.</p> <p>Components, on the other hand, are the detailed, interactive or static elements such as buttons, text fields, and sliders that reside within blocks. These elements are highly customizable and reusable, designed to perform specific functions or convey particular information. Components depend on blocks for context and placement, but their modularity allows them to be used in multiple scenarios across the platform.</p> <p>The primary distinction lies in their scale and function: blocks form the UI's structural foundation, while components populate these structures with content and interactivity. Understanding this difference is crucial for efficient design and development within Netherlands3D, ensuring a robust and user-friendly interface.</p>"},{"location":"developers/ui/understanding-blocks/#conclusion","title":"Conclusion","text":"<p>Blocks are foundational to the Netherlands3D UI design system, offering the structural basis for our digital twin platform. By leveraging blocks effectively, we can ensure a robust, user-friendly interface that reflects the innovative spirit of digital twin technology.</p> <p>The following chapter will detail the components within these blocks, including their design and role in enhancing the interactive experience of Netherlands3D.</p>"},{"location":"developers/ui/understanding-components/","title":"Understanding Components","text":"<p>In this chapter, we delve deeper into the essence of components\u2014the dynamic and interactive elements that enable users to engage with the Netherlands3D platform effectively. Components are the individual pieces of the user interface, such as buttons, sliders, dropdown menus, and data visualization charts, which users interact with directly.</p>"},{"location":"developers/ui/understanding-components/#what-are-components","title":"What Are Components?","text":"<p>Components are the versatile and interactive building blocks housed within the UI's structural blocks. They range from  input fields (where users can enter data), buttons (like 'Submit' or 'Cancel'), sliders (for adjusting settings or zoom levels), to more complex elements such as the minimap (allowing users to explore).</p>"},{"location":"developers/ui/understanding-components/#features-of-components","title":"Features of Components","text":"<ul> <li> <p>Reusability: Designed for reuse, components like toggle switches for on/off settings ensure consistency and    streamline development across Netherlands3D.</p> </li> <li> <p>Customization: Components can be tailored for different informational purposes to adhere to the specific aesthetic    of the platform.</p> </li> <li> <p>Interactivity: Interactive components, such as accordions, for customization features or detailed content    display, to engage users directly, offering a dynamic experience.</p> </li> </ul>"},{"location":"developers/ui/understanding-components/#designing-components","title":"Designing Components","text":"<p>The design of components focuses on the user's needs, aiming for clarity, efficiency, and aesthetic harmony:</p> <ul> <li> <p>User-Centric Design: Components are crafted to be intuitive and accessible for easy   navigation or with validation to guide user input.</p> </li> <li> <p>Aesthetic Consistency: Despite their diversity, components maintain the Netherlands3D's cohesive design language, </p> </li> <li>reinforcing brand identity.</li> </ul>"},{"location":"developers/ui/understanding-components/#managing-components","title":"Managing Components","text":"<p>The lifecycle of components in Netherlands3D involves continuous evaluation and refinement:</p> <ol> <li> <p>Identification of Needs: New functionalities might require the development of novel components interaction with     the 3D environment or its data.</p> </li> <li> <p>Rigorous Testing: Components undergo extensive testing.</p> </li> <li> <p>Iterative Improvement: Feedback might lead to the evolution of components, such as enhancing them    for better data visualization or for improved usability.</p> </li> </ol>"},{"location":"developers/ui/understanding-components/#conclusion","title":"Conclusion","text":"<p>Components are vital for the interactive and functional richness of the Netherlands3D platform. Each component plays a  crucial role in engaging users and facilitating a smooth experience. Through careful design and management, components  ensure Netherlands3D remains an intuitive, efficient, and visually appealing platform.</p>"},{"location":"developers/ui/blocks/property-panel-and-sections/","title":"Properties","text":""},{"location":"developers/ui/blocks/property-panel-and-sections/#design","title":"Design","text":""},{"location":"developers/ui/blocks/property-panel-and-sections/#usage","title":"Usage","text":"<p>The \"Properties\" block in Netherlands3D serves as a critical interface element, allowing users to interact with and modify the attributes of various layers within the application. This documentation provides insights into the design considerations and implementation strategies for this block, ensuring a seamless integration within the Netherlands3D platform.</p> <p>This block enables users to access and adjust the transformation properties (position, rotation, scale) of selected 3D objects or layers. Additionally, it provides access to specific attributes for certain objects, such as Windmills, which may include properties like axis height or rotor diameter.</p> A screenshot of a windmill with an open properties panel"},{"location":"developers/ui/blocks/property-panel-and-sections/#anatomy","title":"Anatomy","text":"Anatomical breakdown of the properties block <p>The Properties panel is constructed using a Card component, organized into several key areas for intuitive user interaction:</p> <ol> <li>Card: The overarching container for the Properties panel, designed for clarity and    cohesion.</li> <li>Card Header: Displays the Properties icon and the term \"Eigenschappen,\" indicating the    panel's purpose.</li> <li>Section: Each layer or object type, such as Windmills, has its dedicated section within the card.</li> <li>Section Header: Identifies the specific layer or object type, e.g., \"Windmolen\" for Windmills, guiding users to the    relevant properties.</li> <li>Section Content: Contains form elements for adjusting the specific properties of the selected layer or object. This    area is designed for direct interaction, allowing users to modify attributes like axis height or rotor diameter.</li> </ol>"},{"location":"developers/ui/blocks/property-panel-and-sections/#design-principles","title":"Design Principles","text":"<ul> <li>Clarity: The use of a card-based layout ensures that the Properties panel is easily navigable and understandable,   with distinct sections for different layers or objects.</li> <li>Consistency: Maintaining a uniform structure across different sections ensures that users have a cohesive   experience, regardless of the variety of objects or layers they interact with.</li> <li>Immediate Feedback: Interactions within the Properties panel are designed to provide immediate visual feedback in   the Netherlands3D environment, emphasizing the panel's role in direct manipulation of objects and layers.</li> </ul>"},{"location":"developers/ui/blocks/property-panel-and-sections/#interaction","title":"Interaction","text":"<p>Users interact with the Properties panel by selecting an object or layer within the Netherlands3D platform, and clicking on the properties button with that layer.</p> <p>Upon opening, the panel updates to display the relevant sections for the chosen item. Adjustments made within the form elements of a section are immediately applied, allowing users to see the effects of their changes in real-time. This design supports a tactile and intuitive experience, encouraging exploration and modification within the digital twin environment.</p>"},{"location":"developers/ui/blocks/property-panel-and-sections/#implementation","title":"Implementation","text":""},{"location":"developers/ui/blocks/property-panel-and-sections/#overview","title":"Overview","text":"<p>The Properties panel's functionality in the Netherlands3D platform is achieved through a combination of Unity prefabs and scripting. This implementation ensures dynamic interaction within the UI, allowing for the seamless addition of properties sections based on the selected layer or object.</p>"},{"location":"developers/ui/blocks/property-panel-and-sections/#prefab-structure","title":"Prefab Structure","text":"<ul> <li> <p>Main Properties Prefab: The core of the Properties panel, this prefab is a part of the default canvas and acts as   the container for all dynamically added sections.</p> </li> <li> <p>Section Prefabs: Individual prefabs for each type of section (e.g., Windmill properties) that can be instantiated   within the main Properties panel.</p> </li> </ul>"},{"location":"developers/ui/blocks/property-panel-and-sections/#scripting-and-interfaces","title":"Scripting and Interfaces","text":""},{"location":"developers/ui/blocks/property-panel-and-sections/#ipropertysection-interface","title":"IPropertySection Interface","text":"<p>An essential element in the dynamic nature of the Properties panel is the <code>IPropertySection</code> interface. This interface allows for the detection and instantiation of properties sections based on the presence of specific MonoBehaviours within a layer's prefab.</p> <ul> <li> <p>Detection and Instantiation: A script running in the layer system detects MonoBehaviours that implement   the <code>IPropertySection</code> interface on a layer's prefab being added to the scene. Upon detection, the <code>AddToProperties</code>   method of the interface is called.</p> </li> <li> <p>Factory Behavior: Implementations of the <code>IPropertySection</code> can act as factories, instantiating the appropriate   section prefab and adding it to the Properties panel as a \"slot\". The <code>AddToProperties</code> method is being provided with   the properties content area to which the section can be added.</p> </li> </ul>"},{"location":"developers/ui/blocks/property-panel-and-sections/#addtoproperties-method","title":"AddToProperties Method","text":"<p>The <code>AddToProperties</code> method is where the logic for instantiating the section prefab and integrating it into the Properties panel is defined. This method allows for flexibility in the UI, permitting custom designs per section while adhering to the overall design guidelines.</p> <p>Example</p>"},{"location":"developers/ui/blocks/property-panel-and-sections/#example-windmill-property-section","title":"Example: Windmill Property Section","text":"<p>The Windmolen prefab, used for the Windmill implementation in the Object Library, includes a MonoBehaviour named <code>WindmillPropertySectionInstantiator</code> that demonstrates this system in action.</p> <ul> <li> <p>Functionality: The <code>WindmillPropertySectionInstantiator</code> responds to the addition of a Windmill object and   instantiates a dedicated section within the Properties panel. This section is specifically designed to bind and   display the properties of the windmill, such as axis height or rotor diameter.</p> </li> <li> <p>Binding: The script binds the windmill's data to the instantiated section, ensuring that any adjustments made     within the Properties panel are immediately reflected in the windmill's properties within the scene.</p> </li> </ul>"},{"location":"developers/ui/blocks/property-panel-and-sections/#implementation-steps","title":"Implementation Steps","text":"<p>Given an existing layer's prefab:</p> <p>Implement the IPropertySection interface: For each layer requiring a properties section, create a MonoBehaviour  that implements <code>IPropertySection</code> and defines how its section prefab should be instantiated and added to the  Properties panel.</p>"},{"location":"developers/ui/blocks/property-panel-and-sections/#design-adherence","title":"Design Adherence","text":"<p>While implementing sections, it's crucial to adhere to the established design rules to maintain consistency across the Properties panel. However, the flexibility of this system allows for the introduction of unique UI elements where necessary to better represent specific properties.</p>"},{"location":"developers/ui/components/accordion/","title":"Accordion","text":""},{"location":"developers/ui/components/accordion/#design","title":"Design","text":""},{"location":"developers/ui/components/accordion/#usage","title":"Usage","text":"<p>The Accordion component in the Netherlands3D platform is a versatile UI element designed to efficiently manage and display hierarchical content in a compact form. Featuring a title, an optional label, and a toggle mechanism indicated by a chevron, the Accordion allows for an organized presentation of content sections, each with its dedicated header to signify its integration within the Accordion. This component is ideal for:</p> <ul> <li> <p>Settings Menus: Grouping related settings or options to streamline user navigation, such as layer property sections.</p> </li> <li> <p>Grouping Content: Grouping related content to focus on related information, such as quality indicator dossiers.</p> </li> <li> <p>Interactive FAQs: Presenting frequently asked questions in a concise, expandable format.</p> </li> </ul>"},{"location":"developers/ui/components/accordion/#modes-of-operation","title":"Modes of Operation","text":"<ol> <li> <p>Fixed Mode: This mode locks the Accordion in an always-open state, without the option to collapse or expand. The    absence of a chevron signifies its static nature.</p> </li> <li> <p>Multiple Open Mode: Allows for multiple Accordions within a group to be opened or closed independently. The chevron    points up when opened, indicating a \"roll-up\" action, and down when closed, suggesting a \"roll-down\" action.</p> </li> <li> <p>Single Open Mode: In a group of Accordions, only one can be open at a time. Opening another Accordion automatically    closes the previously open one. This mode features a chevron pointing down when closed; and when open, the chevron is    hidden, supplemented by an additional outline to highlight the Accordion is considered to be an active -or selected-    Accordion.</p> </li> </ol>"},{"location":"developers/ui/components/accordion/#anatomy","title":"Anatomy","text":"Anatomical breakdown of the Accordion component <ol> <li> <p>Title: A text representative of the Accordion's content.</p> </li> <li> <p>Icon (Optional): Provides additional context or classification.</p> </li> <li> <p>Expand/Contract Toggle (Optional): A chevron-based toggle mechanism indicating the Accordion's state and     possible actions.</p> </li> <li> <p>Content Section: The expandable area containing detailed content or components.</p> </li> <li> <p>Content Header: A header within the content section styled specifically to emphasize its connection to the     Accordion.</p> </li> </ol>"},{"location":"developers/ui/components/accordion/#design-principles","title":"Design Principles","text":""},{"location":"developers/ui/components/accordion/#title-and-icon","title":"Title and Icon","text":"<p>The title provides a succinct summary of the content contained within the Accordion, while the optional icon offers  additional context or categorization.</p> <p>Both elements are designed to be immediately visible to enhance usability and guide the user's navigation through the  content sections.</p>"},{"location":"developers/ui/components/accordion/#expandcontract-toggle","title":"Expand/Contract Toggle","text":"<p>The Expand/Contract Toggle includes a chevron symbol that visually communicates the Accordion's state and possible  actions to the user. The direction of the chevron indicates the effect of the interaction (down for roll-down, up for  roll-up).</p> <p>The toggle may be absent when there is no action available, as can be the case for the fixed mode of operation or when no roll-up is provided because one element always needs to be open.</p>"},{"location":"developers/ui/components/accordion/#content-section","title":"Content Section","text":"<p>The content section beneath each Accordion title is designed for expandability, housing detailed information or  additional UI components.</p> <p>Optionally, a specific header within the content section further emphasizes its association with the Accordion.</p>"},{"location":"developers/ui/components/accordion/#best-practices","title":"Best Practices","text":"<ul> <li> <p>Clarity: Ensure the title and label (if used) are clear and informative, guiding the user's understanding of the   content within.</p> </li> <li> <p>Intuitive Interaction: Design the Expand Toggle for easy recognition and interaction, with chevron icons that   intuitively indicate the possible actions.</p> </li> <li> <p>Consistency: Maintain visual and functional consistency across all Accordion components, especially within groups   operating in multiple or single open modes.</p> </li> </ul>"},{"location":"developers/ui/components/accordion/#implementation","title":"Implementation","text":"<p>Info</p> <p>As of writing, there is no component in Unity available to provide the Accordion component. This part of the  documentation should be updated as soon as one is available.</p>"},{"location":"developers/ui/components/cards/","title":"Cards","text":""},{"location":"developers/ui/components/cards/#usage","title":"Usage","text":"<p>Cards are surfaces that display content and actions on a single topic.</p> <p>They should be easy to scan for relevant and actionable information. Elements, like text and images, should be placed on them in a way that clearly indicates hierarchy.</p>"},{"location":"developers/ui/components/cards/#anatomy","title":"Anatomy","text":"<p>Info</p> <p>The contents of this chapter need to be written </p>"},{"location":"developers/ui/components/double-sliders/","title":"Double Slider","text":""},{"location":"developers/ui/components/double-sliders/#design","title":"Design","text":""},{"location":"developers/ui/components/double-sliders/#usage","title":"Usage","text":"<p>Similar to the slider component, the double slider component in the Netherlands3D platform provides  a graphical interface element enabling users to select a range between two values from a predefined scale.  Accompanied by two Text Fields, this component allows for both graphical adjustment and direct numerical input, ensuring a versatile and user-friendly experience. The main difference between the double slider and the regular slider is that the double slider has two handles and input fields, defining the minimum and maximum value of the range.</p>"},{"location":"developers/ui/components/double-sliders/#immediate-effects","title":"Immediate effects","text":"<p>Changes made with double sliders are immediate, allowing the user to make slider adjustments while determining a selection. Sliders shouldn\u2019t be used to adjust settings with any delay in providing user feedback.</p>"},{"location":"developers/ui/components/double-sliders/#current-state","title":"Current state","text":"<p>Sliders reflect the current state of the settings they control.</p>"},{"location":"developers/ui/components/double-sliders/#anatomy","title":"Anatomy","text":"Anatomical breakdown of the double slider component <ol> <li>Slider Track: The horizontal line along which the double slider thumb moves, representing the range of possible values.</li> <li>Minimum Slider Thumb: The circular control that users drag to select the minimum value on the slider track.</li> <li>Minimum Text Field (Optional): Adjacent to the double slider, this field displays the currently selected minimum value and allows for manual    entry. It can be configured as readonly or omitted based on specific requirements.</li> <li>Maximum Slider Thumb: The circular control that users drag to select the maximum value on the slider track.</li> <li>Maximum Text Field (Optional): Adjacent to the double slider, this field displays the currently selected maximum value and allows for manual    entry. It can be configured as readonly or omitted based on specific requirements.</li> </ol>"},{"location":"developers/ui/components/double-sliders/#implementation","title":"Implementation","text":"<p>This chapter guides you through adding the double slider prefab to your scene, configuring its behavior, and responding to user input.</p>"},{"location":"developers/ui/components/double-sliders/#adding-the-slider-to-your-scene","title":"Adding the Slider to Your Scene","text":"<ol> <li> <p>Prefab Placement: Locate the double slider prefab in the project's asset directory. Drag and drop the prefab into your    scene or hierarchy where you need the slider component to appear.</p> </li> <li> <p>Initial Setup: By default, the double slider comes with linked Text Fields for numerical input. Together, they provide    a cohesive component for value selection.</p> </li> </ol>"},{"location":"developers/ui/components/double-sliders/#configuring-the-slider","title":"Configuring the Slider","text":""},{"location":"developers/ui/components/double-sliders/#listening-to-value-changes","title":"Listening to Value Changes","text":"<p>Use the Unity Editor to attach a listener function to the slider's <code>onMinValueChanged</code> and <code>onMaxValueChanged</code> events. These functions will be called whenever the slider's minimum or maximum value changes, respectively, whether through direct manipulation of the double slider or numerical entry in the Text Fields.</p>"},{"location":"developers/ui/components/double-sliders/#customizing-the-text-field","title":"Customizing the Text Field","text":"<ul> <li> <p>Readonly Option: The <code>DoubleSlider</code> MonoBehaviour includes a <code>readonly</code> boolean. When set to true, the Text   Fields becomes readonly, allowing users to see the value but preventing manual entry. This is useful in situations   where you want to restrict input to slider manipulation only.</p> </li> <li> <p>Omitting the Text Field: If your use case does not require numerical input, you can deactivate the Text Fields   entirely. Simply set the Text Field GameObjects to inactive, and the double slider will automatically expand to fill the   space, maintaining the UI's visual continuity.</p> </li> </ul>"},{"location":"developers/ui/components/sliders/","title":"Slider","text":""},{"location":"developers/ui/components/sliders/#design","title":"Design","text":""},{"location":"developers/ui/components/sliders/#usage","title":"Usage","text":"<p>The slider component in the Netherlands3D platform provides a graphical interface element enabling users to select a value or range from a predefined scale. Accompanied by a Text Field, this component allows for both graphical adjustment and direct numerical input, ensuring a versatile and user-friendly experience.</p>"},{"location":"developers/ui/components/sliders/#immediate-effects","title":"Immediate effects","text":"<p>Changes made with sliders are immediate, allowing the user to make slider adjustments while determining a selection. Sliders shouldn\u2019t be used to adjust settings with any delay in providing user feedback.</p>"},{"location":"developers/ui/components/sliders/#current-state","title":"Current state","text":"<p>Sliders reflect the current state of the settings they control.</p>"},{"location":"developers/ui/components/sliders/#anatomy","title":"Anatomy","text":"Anatomical breakdown of the slider component <ol> <li>Slider Track: The horizontal line along which the slider thumb moves, representing the range of possible values.</li> <li>Slider Thumb: The circular control that users drag to select a value on the slider track.</li> <li>Text Field (Optional): Adjacent to the slider, this field displays the currently selected value and allows for manual    entry. It can be configured as readonly or omitted based on specific requirements.</li> </ol>"},{"location":"developers/ui/components/sliders/#implementation","title":"Implementation","text":"<p>This chapter guides you through adding the slider prefab to your scene, configuring its behavior, and responding to user input.</p>"},{"location":"developers/ui/components/sliders/#adding-the-slider-to-your-scene","title":"Adding the Slider to Your Scene","text":"<ol> <li> <p>Prefab Placement: Locate the slider prefab in the project's asset directory. Drag and drop the prefab into your    scene or hierarchy where you need the slider component to appear.</p> </li> <li> <p>Initial Setup: By default, the slider comes with a linked Text Field for numerical input. Together, they provide    a cohesive component for value selection.</p> </li> </ol>"},{"location":"developers/ui/components/sliders/#configuring-the-slider","title":"Configuring the Slider","text":""},{"location":"developers/ui/components/sliders/#listening-to-value-changes","title":"Listening to Value Changes","text":"<p>Use the Unity Editor to attach a listener function to the slider's <code>onValueChanged</code> event. This function will be called whenever the slider's value changes, whether through direct manipulation of the slider or numerical entry in the Text Field.</p>"},{"location":"developers/ui/components/sliders/#customizing-the-text-field","title":"Customizing the Text Field","text":"<ul> <li> <p>Readonly Option: The <code>PropertySlider</code> MonoBehaviour includes a <code>readonly</code> boolean. When set to true, the Text   Field becomes readonly, allowing users to see the value but preventing manual entry. This is useful in situations   where you want to restrict input to slider manipulation only.</p> </li> <li> <p>Omitting the Text Field: If your use case does not require numerical input, you can deactivate the Text Field   entirely. Simply set the Text Field GameObject to inactive, and the slider will automatically expand to fill the   space, maintaining the UI's visual continuity.</p> </li> </ul>"},{"location":"developers/ui/components/text-fields/","title":"Text Field","text":""},{"location":"developers/ui/components/text-fields/#design","title":"Design","text":""},{"location":"developers/ui/components/text-fields/#usage","title":"Usage","text":"<p>\"Text Fields\" in the Netherlands3D platform allow users to input or modify text information. They can be used singularly or in combination with other components like a Slider or Form Label in the Properties block. They're an essential part of Netherlands3D's user interface, providing users with interactive fields to enter or manipulate various properties.</p>"},{"location":"developers/ui/components/text-fields/#parts","title":"Parts","text":"<p>The Text Field component comprises two main parts:</p> <ol> <li> <p>Form Label: The descriptive text associated with the Text Field, explaining what value is being manipulated. This    is a reusable part and can be shared with other components like the Slider.</p> </li> <li> <p>Form Field: It serves as the component for user text input or changing text information. It is styled to account    for different states like Idle, Focus, Pressing, and Read-Only.</p> </li> </ol>"},{"location":"developers/ui/components/text-fields/#anatomy","title":"Anatomy","text":"<p>Note</p> <p>Add an image to showcase the anatomy of a form field and elaborate some more on this in the text</p> <ol> <li> <p>Form Label: Positioned above or adjacent to the Form Field, providing a textual description of the information    required or displayed.</p> </li> <li> <p>Form Field: The interactive text input area where users can enter or modify data. It transitions between various    states (Idle, Focus, Pressed, Read-only) to visually communicate its current mode of interaction.</p> </li> </ol>"},{"location":"developers/ui/components/text-fields/#design-principles","title":"Design Principles","text":"<ul> <li> <p>Clarity: Labels are clear and informative, ensuring users understand what information is required.</p> </li> <li> <p>Feedback: Built-in states (Idle, Focused, Pressed, and Read-Only) provide immediate visual feedback to users,   aiding an interactive experience.</p> </li> </ul>"},{"location":"developers/ui/components/text-fields/#implementation","title":"Implementation","text":"<p>The Text Field is modeled using Unity prefabs and scripting, offering dynamic interaction within the user interface, allowing for adaptive properties adjustment based on user input.</p>"},{"location":"developers/ui/components/text-fields/#adding-a-text-field-to-your-scene","title":"Adding a Text Field to Your Scene","text":"<ul> <li>Prefab Placement: Locate the Text Field prefab in the project's asset directory. Drag and drop the prefab into your   scene where you need the Text Field component to appear.</li> </ul>"},{"location":"developers/ui/components/text-fields/#configuring-the-text-field","title":"Configuring the Text Field","text":"<p>You can utilize the Unity Editor to add listener functions that get triggered on text value change events, enabling you to manipulate and use the user-input text as per application needs.</p>"},{"location":"organisations/getting-started/","title":"Getting Started","text":"<p>Netherlands3D provides several ways to get started and integrate the digital twin into your projects. Choose the method that best fits your needs and level of expertise:</p>"},{"location":"organisations/getting-started/#embed-or-share-netherlands3d","title":"Embed or share Netherlands3D","text":"<p>Embedding Netherlands3D is perfect for webmasters, bloggers, or anyone who wants to add the Netherlands3D digital twin to their website or content management system (CMS) without needing to worry about complex setup. It's a quick and easy way to showcase the digital twin.</p> <p>You can also use it as a shareable link, making it easy to share the digital twin with others.</p> <p>Target Audience: Webmasters, organisations without their own infrastructure, one-off showcases or demonstrations.</p> <ul> <li>Learn how to embed Netherlands3D using an iframe</li> <li>Get a Shareable Link</li> </ul>"},{"location":"organisations/getting-started/#self-host-netherlands3d","title":"Self-Host Netherlands3D","text":"<p>Self-hosting Netherlands3D is great if you have your own website and need more control. It's suitable for those who want to interact with subscription services or databases and want to customize their setup. If you have a domain and some technical skills, this option is for you.</p> <p>Target Audience: government or private organisations with their own domain and infrastructure</p> <ul> <li>Host Netherlands3D using Docker</li> <li>Build Netherlands3D from Source</li> <li>Build a fully customized Digital Twin using our packages</li> </ul>"},{"location":"organisations/getting-started/#use-the-hosted-version-apply-for-access","title":"Use the Hosted Version (Apply for Access)","text":"<p>The hosted version provides an Azure Subscription with a pre-built environment, eliminating the need for you to bring your own infrastructure. After onboarding, you can customize the environment to suit your specific requirements. This option is suitable for those who need to interact with subscription services and prefer a pre-configured setup.</p> <p>Target Audience: Organisations who want a pre-built environment without the need for their own infrastructure.</p> <ul> <li>Apply for Access to the Hosted Version</li> </ul>"}]}